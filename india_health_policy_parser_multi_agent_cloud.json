{
  "name": "India Health Policy Parser - Multi Agent (Cloud)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "policy-upload",
        "responseMode": "responseNode",
        "options": {
          "binaryData": true
        }
      },
      "id": "webhook_upload",
      "name": "Webhook Upload",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1320,
        -180
      ]
    },
    {
      "parameters": {
        "options": {
          "allowFileUploads": true
        }
      },
      "id": "chat_upload",
      "name": "Chat Upload",
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.0,
      "position": [
        -1320,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const out = [];\nfor (const item of $input.all()) {\n  const j = item.json || {};\n  const b = item.binary || {};\n  const fromWebhook = !!j.headers;\n  const fromChat = !fromWebhook;\n\n  let binaryPropertyName = 'file';\n  if (!b.file) {\n    const firstKey = Object.keys(b)[0];\n    if (firstKey) binaryPropertyName = firstKey;\n  }\n\n  const bin = b[binaryPropertyName] || {};\n  const filename = bin.fileName || bin.fileName || j.fileName || null;\n  const mime = bin.mimeType || j.mimeType || 'application/octet-stream';\n  const size = bin.fileSize || null;\n\n  out.push({\n    json: {\n      entrypoint: fromWebhook ? 'webhook' : 'chat',\n      file_meta: { filename, mime, size },\n      binary_property_name: binaryPropertyName,\n      extracted_text: null,\n      scanner: {},\n      gap: {},\n      user_context: j.user_context || {},\n      policy_json: {},\n      text_hash: null\n    },\n    binary: b\n  });\n}\nreturn out;"
      },
      "id": "normalize_binary",
      "name": "Normalize Binary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1080,
        -40
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.file_meta.mime}}",
                    "rightValue": "pdf",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "pdf"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.file_meta.mime + ' ' + ($json.file_meta.filename || '')}}",
                    "rightValue": "docx",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "docx"
            }
          ]
        },
        "fallbackOutput": "other"
      },
      "id": "filetype_router",
      "name": "File Type Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -860,
        -40
      ]
    },
    {
      "parameters": {
        "operation": "pdf",
        "binaryPropertyName": "={{$json.binary_property_name}}"
      },
      "id": "extract_built_in",
      "name": "Extract Text (Built-in)",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -620,
        -180
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$json.file_meta.mime && $json.file_meta.mime.includes('pdf') ? $env.PDF_TEXT_EXTRACT_URL : $env.DOCX_TEXT_EXTRACT_URL}}",
        "sendBinaryData": true,
        "binaryPropertyName": "={{$json.binary_property_name}}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "extract_external",
      "name": "Extract Text (External)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -620,
        40
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map((item) => {\n  const j = item.json || {};\n  const textCandidate = j.text || j.data?.text || j.extractedText || j.extracted_text || '';\n  const extracted_text = String(textCandidate || '').trim();\n  return {\n    json: { ...j, extracted_text },\n    binary: item.binary\n  };\n});"
      },
      "id": "merge_extracted",
      "name": "Merge Extracted Text",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -380,
        -40
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "short-text",
              "leftValue": "={{($json.extracted_text || '').length}}",
              "rightValue": 500,
              "operator": {
                "type": "number",
                "operation": "smaller"
              }
            }
          ],
          "combinator": "or"
        }
      },
      "id": "ocr_length_if",
      "name": "OCR Needed? (IF)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -180,
        -40
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.OCR_EXTRACT_URL}}",
        "sendBinaryData": true,
        "binaryPropertyName": "={{$json.binary_property_name}}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "ocr_fallback",
      "name": "OCR Fallback",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        20,
        -160
      ]
    },
    {
      "parameters": {
        "jsCode": "function sanitize(text) {\n  const lines = String(text || '').split(/\\r?\\n/).map(l => l.trim()).filter(Boolean);\n  const freq = new Map();\n  for (const l of lines) freq.set(l, (freq.get(l) || 0) + 1);\n  const filtered = lines.filter(l => (freq.get(l) || 0) < 6);\n  return filtered.join('\\n').replace(/[\\t ]+/g, ' ').replace(/\\n{3,}/g, '\\n\\n').trim();\n}\n\nfunction rightRotate(value, amount) {\n  return (value >>> amount) | (value << (32 - amount));\n}\n\nfunction sha256(ascii) {\n  const mathPow = Math.pow;\n  const maxWord = mathPow(2, 32);\n  let result = '';\n  const words = [];\n  const asciiBitLength = ascii.length * 8;\n  let hash = sha256.h = sha256.h || [];\n  let k = sha256.k = sha256.k || [];\n  let primeCounter = k.length;\n\n  const isComposite = {};\n  for (let candidate = 2; primeCounter < 64; candidate++) {\n    if (!isComposite[candidate]) {\n      for (let i = 0; i < 313; i += candidate) {\n        isComposite[i] = candidate;\n      }\n      hash[primeCounter] = (mathPow(candidate, 0.5) * maxWord) | 0;\n      k[primeCounter++] = (mathPow(candidate, 1 / 3) * maxWord) | 0;\n    }\n  }\n\n  ascii += '\\x80';\n  while ((ascii.length % 64) - 56) ascii += '\\x00';\n  for (let i = 0; i < ascii.length; i++) {\n    const j = ascii.charCodeAt(i);\n    if (j >> 8) return null;\n    words[i >> 2] |= j << (((3 - i) % 4) * 8);\n  }\n  words[words.length] = ((asciiBitLength / maxWord) | 0);\n  words[words.length] = (asciiBitLength);\n\n  for (let j = 0; j < words.length;) {\n    const w = words.slice(j, (j += 16));\n    const oldHash = hash.slice(0);\n\n    for (let i = 0; i < 64; i++) {\n      const w15 = w[i - 15], w2 = w[i - 2];\n      const a = hash[0], e = hash[4];\n      const temp1 = hash[7]\n        + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25))\n        + ((e & hash[5]) ^ ((~e) & hash[6]))\n        + k[i]\n        + (w[i] = (i < 16) ? w[i] : (\n            w[i - 16]\n            + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15 >>> 3))\n            + w[i - 7]\n            + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2 >>> 10))\n          ) | 0);\n      const temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22))\n        + ((a & hash[1]) ^ (a & hash[2]) ^ (hash[1] & hash[2]));\n\n      hash = [(temp1 + temp2) | 0].concat(hash);\n      hash[4] = (hash[4] + temp1) | 0;\n      hash.pop();\n    }\n\n    for (let i = 0; i < 8; i++) {\n      hash[i] = (hash[i] + oldHash[i]) | 0;\n    }\n  }\n\n  for (let i = 0; i < 8; i++) {\n    for (let j = 3; j + 1; j--) {\n      const b = (hash[i] >> (j * 8)) & 255;\n      result += ((b < 16) ? 0 : '') + b.toString(16);\n    }\n  }\n  return result;\n}\n\nreturn $input.all().map((item) => {\n  const j = item.json || {};\n  const ocrText = j.text || j.data?.text || '';\n  const baseText = j.extracted_text || '';\n  const chosen = String(ocrText || baseText || '');\n  const cleaned = sanitize(chosen);\n  const capped = cleaned.slice(0, 120000);\n  const first_12000_chars = capped.slice(0, 12000);\n  const text_hash = sha256(capped) || null;\n  return {\n    json: {\n      ...j,\n      extracted_text: capped,\n      first_12000_chars,\n      text_hash\n    },\n    binary: item.binary\n  };\n});"
      },
      "id": "sanitize_hash",
      "name": "Sanitize & Hash",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        240,
        -40
      ]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1
        }
      },
      "id": "openai_chat_model_scanner",
      "name": "OpenAI Chat Model (Scanner)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        460,
        -260
      ],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "You are Policy Scanner (India). Input: first_12000_chars and file_meta. Return STRICT JSON only following the required schema.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Extract only what is present. Unknown => null. Country must be India."
        }
      },
      "id": "policy_scanner",
      "name": "Policy Scanner",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        680,
        -40
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"detected\": {\n    \"is_health_insurance\": null,\n    \"country\": \"India\",\n    \"document_type\": null,\n    \"insurer_name\": null,\n    \"product_name\": null,\n    \"uin\": null,\n    \"plan_names_found\": [\"example\"],\n    \"sum_insured_options_found\": [\"example\"],\n    \"has_family_floater_terms\": null,\n    \"has_zone_terms\": null,\n    \"riders_or_addons_mentioned\": [\"example\"],\n    \"key_sections_found\": {\n      \"waiting_periods\": null,\n      \"room_rent\": null,\n      \"pre_post_hosp\": null,\n      \"exclusions\": null\n    }\n  },\n  \"evidence\": [\n    { \"field\": null, \"snippet\": null, \"source_ref\": null }\n  ],\n  \"confidence\": { \"overall\": null, \"notes\": null }\n}"
      },
      "id": "scanner_parser",
      "name": "Scanner Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        680,
        -260
      ]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1
        }
      },
      "id": "openai_chat_model_gap",
      "name": "OpenAI Chat Model (Gap)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        920,
        -260
      ],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "You are Context Gap Detector. Ask minimum ranked questions only if needed.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Use scanner output and user_context. Output strict JSON only."
        }
      },
      "id": "context_gap_detector",
      "name": "Context Gap Detector",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1140,
        -40
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"need_user_input\": null,\n  \"questions\": [\n    {\n      \"id\": null,\n      \"question\": null,\n      \"type\": \"single_select|multi_select|text|number|object\",\n      \"options\": [\"option\"],\n      \"required\": null,\n      \"reason\": null\n    }\n  ],\n  \"assumptions_if_unanswered\": [\n    { \"field\": null, \"assumption\": null, \"risk\": \"low|medium|high\" }\n  ],\n  \"stop_condition\": \"ask_questions_then_resume|continue\"\n}"
      },
      "id": "gap_parser",
      "name": "Gap Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        1140,
        -260
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{$json.need_user_input}}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "needs_context_if",
      "name": "Needs Context? (IF)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1360,
        -40
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = this.getWorkflowStaticData('global');\nfor (const item of $input.all()) {\n  const key = item.json.text_hash;\n  if (key) {\n    data[key] = {\n      extracted_text: item.json.extracted_text,\n      file_meta: item.json.file_meta,\n      scanner: item.json.detected || item.json.scanner?.detected || {},\n      binary_property_name: item.json.binary_property_name,\n      saved_at: new Date().toISOString()\n    };\n  }\n}\nreturn $input.all();"
      },
      "id": "store_pending",
      "name": "Store Pending Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1580,
        -180
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map((item)=>{\n  const questions = item.json.questions || [];\n  const payload = {\n    status: 'needs_context',\n    questions,\n    detected: item.json.detected || {},\n    text_hash: item.json.text_hash\n  };\n  return {json: {...item.json, response_payload: payload}};\n});"
      },
      "id": "assemble_needs_context",
      "name": "Assemble Needs Context Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        -180
      ]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1
        }
      },
      "id": "openai_chat_model_deep",
      "name": "OpenAI Chat Model (Deep)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        1580,
        220
      ],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Deep Extractor (India Policy -> Schema JSON). Use full extracted_text + file_meta + scanner.detected + user_context. Return JSON object only (no markdown, no prose). Use null for unknowns.",
        "hasOutputParser": false,
        "options": {
          "systemMessage": "Output raw JSON only. Do not wrap in code fences. Prefer exact field names from downstream schema."
        }
      },
      "id": "deep_extractor",
      "name": "Deep Extractor",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1800,
        220
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"document_classification\": {\n    \"is_health_insurance\": null,\n    \"india_market\": true,\n    \"document_type\": null,\n    \"confidence\": { \"overall\": null, \"rationale\": null }\n  },\n  \"policy_metadata\": {\n    \"insurer_name\": null,\n    \"product_name\": null,\n    \"uin\": null,\n    \"plan_name\": null,\n    \"policy_type\": null,\n    \"individual_or_floater\": null,\n    \"policy_number\": null,\n    \"certificate_number\": null,\n    \"tpa_name\": null,\n    \"network\": {\n      \"cashless_available\": null,\n      \"network_name_or_partner\": null,\n      \"non_network_reimbursement_allowed\": null\n    },\n    \"policy_period\": { \"start_date\": null, \"end_date\": null },\n    \"geography\": { \"zone_or_city_tier\": null, \"india_state\": null, \"city\": null },\n    \"sum_insured\": { \"raw\": null, \"amount\": null, \"currency\": \"INR\", \"type\": null },\n    \"insured_members\": { \"count\": null, \"relationships\": null, \"entry_age_rules\": null }\n  },\n  \"premium_and_tax\": {\n    \"premium\": { \"raw\": null, \"amount\": null, \"currency\": \"INR\", \"frequency\": null },\n    \"gst_or_taxes\": { \"raw\": null, \"rate\": null },\n    \"loadings_or_discounts\": [\n      { \"type\": null, \"value\": null, \"conditions\": null, \"source_ref\": null }\n    ]\n  },\n  \"cost_sharing\": {\n    \"deductible\": { \"raw\": null, \"amount\": null, \"currency\": \"INR\", \"per\": null, \"notes\": null },\n    \"co_pay\": [\n      { \"trigger\": null, \"raw\": null, \"rate\": null, \"cap\": null, \"notes\": null, \"source_ref\": null }\n    ],\n    \"coinsurance\": [\n      { \"service\": null, \"raw\": null, \"rate\": null, \"notes\": null, \"source_ref\": null }\n    ]\n  },\n  \"waiting_periods\": {\n    \"initial_waiting_period\": { \"raw\": null, \"accident_exception\": null, \"source_ref\": null },\n    \"ped_waiting_period\": { \"raw\": null, \"definition_of_ped\": null, \"source_ref\": null },\n    \"maternity_waiting_period\": { \"raw\": null, \"source_ref\": null },\n    \"specific_disease_waiting_periods\": [\n      { \"condition_or_procedure\": null, \"raw\": null, \"source_ref\": null }\n    ]\n  },\n  \"limits_and_sublimits\": {\n    \"room_rent\": { \"raw\": null, \"type\": null, \"notes\": null, \"source_ref\": null },\n    \"icu_rent\": { \"raw\": null, \"type\": null, \"notes\": null, \"source_ref\": null },\n    \"procedure_or_disease_sublimits\": [\n      { \"item\": null, \"limit_raw\": null, \"notes\": null, \"source_ref\": null }\n    ],\n    \"ambulance_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"ayush_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"cataract_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"opd_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"annual_or_lifetime_limits\": [\n      { \"benefit\": null, \"limit_raw\": null, \"source_ref\": null }\n    ]\n  },\n  \"benefits\": {\n    \"hospitalization_inpatient\": { \"covered\": null, \"notes\": null, \"source_ref\": null },\n    \"pre_hospitalization\": { \"covered\": null, \"duration_raw\": null, \"source_ref\": null },\n    \"post_hospitalization\": { \"covered\": null, \"duration_raw\": null, \"source_ref\": null },\n    \"daycare\": { \"covered\": null, \"definition_or_list\": null, \"source_ref\": null },\n    \"domiciliary_hospitalization\": { \"covered\": null, \"conditions\": null, \"source_ref\": null },\n    \"modern_treatments\": { \"covered\": null, \"limits_or_list\": null, \"source_ref\": null },\n    \"organ_donor\": { \"covered\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"maternity\": {\n      \"covered\": null,\n      \"limit_raw\": null,\n      \"newborn_covered\": null,\n      \"newborn_waiting_or_conditions\": null,\n      \"source_ref\": null\n    },\n    \"mental_health\": { \"covered\": null, \"notes\": null, \"source_ref\": null },\n    \"ayush\": { \"covered\": null, \"notes\": null, \"source_ref\": null },\n    \"health_checkups\": { \"covered\": null, \"frequency_raw\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"vaccination\": { \"covered\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"teleconsultation\": { \"covered\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"restoration_or_reload\": {\n      \"available\": null,\n      \"type\": null,\n      \"conditions\": null,\n      \"usage_rules\": null,\n      \"source_ref\": null\n    },\n    \"no_claim_bonus\": {\n      \"available\": null,\n      \"accrual_raw\": null,\n      \"max_raw\": null,\n      \"reduction_rules\": null,\n      \"source_ref\": null\n    }\n  },\n  \"exclusions\": {\n    \"standard_exclusions\": [\"exclusion item\"],\n    \"product_specific_exclusions\": [\n      { \"exclusion\": null, \"source_ref\": null }\n    ],\n    \"permanent_exclusions_or_ped_exclusions\": [\n      { \"item\": null, \"source_ref\": null }\n    ],\n    \"non_medical_items_consumables\": { \"covered_or_excluded\": null, \"notes\": null, \"source_ref\": null }\n  },\n  \"claims_and_admin\": {\n    \"cashless_process\": null,\n    \"reimbursement_process\": null,\n    \"claim_intimation_timeline\": null,\n    \"document_submission_timeline\": null,\n    \"claim_settlement_timeline\": null,\n    \"free_look_period\": null,\n    \"renewal_and_grace_period\": null,\n    \"portability\": null,\n    \"migration\": null,\n    \"cancellation_refund\": null,\n    \"customer_support\": {\n      \"insurer_helpline\": null,\n      \"tpa_helpline\": null,\n      \"email\": null,\n      \"website\": null,\n      \"address\": null\n    }\n  },\n  \"plan_variants\": [\n    {\n      \"variant_name\": null,\n      \"variant_identifier\": null,\n      \"sum_insured_options\": null,\n      \"cost_sharing_overrides\": null,\n      \"limits_overrides\": null,\n      \"benefit_overrides\": null,\n      \"waiting_period_overrides\": null,\n      \"notes\": null\n    }\n  ],\n  \"notes\": {\n    \"missing_or_unclear\": [\"missing field note\"],\n    \"conflicts\": [\"conflict note\"],\n    \"assumptions\": [\"assumption note\"],\n    \"extraction_warnings\": [\"warning note\"]\n  },\n  \"source_map\": [\n    {\n      \"field_path\": null,\n      \"evidence_snippet\": null,\n      \"source_ref\": null\n    }\n  ]\n}"
      },
      "id": "deep_parser",
      "name": "Deep Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        1800,
        20
      ]
    },
    {
      "parameters": {
        "jsCode": "function extractJson(raw) {\n  if (raw && typeof raw === 'object') return raw;\n  const s = String(raw || '').trim();\n  try { return JSON.parse(s); } catch {}\n  const start = s.indexOf('{');\n  const end = s.lastIndexOf('}');\n  if (start !== -1 && end !== -1 && end > start) {\n    const sub = s.slice(start, end + 1);\n    try { return JSON.parse(sub); } catch {}\n  }\n  return {};\n}\n\nconst TEMPLATE = {\n  document_classification: { is_health_insurance: null, india_market: true, document_type: null, confidence: { overall: null, rationale: null } },\n  policy_metadata: { insurer_name: null, product_name: null, uin: null, plan_name: null, policy_type: null, individual_or_floater: null, policy_number: null, certificate_number: null, tpa_name: null, network: { cashless_available: null, network_name_or_partner: null, non_network_reimbursement_allowed: null }, policy_period: { start_date: null, end_date: null }, geography: { zone_or_city_tier: null, india_state: null, city: null }, sum_insured: { raw: null, amount: null, currency: 'INR', type: null }, insured_members: { count: null, relationships: null, entry_age_rules: null } },\n  premium_and_tax: { premium: { raw: null, amount: null, currency: 'INR', frequency: null }, gst_or_taxes: { raw: null, rate: null }, loadings_or_discounts: [] },\n  cost_sharing: { deductible: { raw: null, amount: null, currency: 'INR', per: null, notes: null }, co_pay: [], coinsurance: [] },\n  waiting_periods: { initial_waiting_period: { raw: null, accident_exception: null, source_ref: null }, ped_waiting_period: { raw: null, definition_of_ped: null, source_ref: null }, maternity_waiting_period: { raw: null, source_ref: null }, specific_disease_waiting_periods: [] },\n  limits_and_sublimits: { room_rent: { raw: null, type: null, notes: null, source_ref: null }, icu_rent: { raw: null, type: null, notes: null, source_ref: null }, procedure_or_disease_sublimits: [], ambulance_limit: { limit_raw: null, source_ref: null }, ayush_limit: { limit_raw: null, source_ref: null }, cataract_limit: { limit_raw: null, source_ref: null }, opd_limit: { limit_raw: null, source_ref: null }, annual_or_lifetime_limits: [] },\n  benefits: { hospitalization_inpatient: { covered: null, notes: null, source_ref: null }, pre_hospitalization: { covered: null, duration_raw: null, source_ref: null }, post_hospitalization: { covered: null, duration_raw: null, source_ref: null }, daycare: { covered: null, definition_or_list: null, source_ref: null }, domiciliary_hospitalization: { covered: null, conditions: null, source_ref: null }, modern_treatments: { covered: null, limits_or_list: null, source_ref: null }, organ_donor: { covered: null, limit_raw: null, source_ref: null }, maternity: { covered: null, limit_raw: null, newborn_covered: null, newborn_waiting_or_conditions: null, source_ref: null }, mental_health: { covered: null, notes: null, source_ref: null }, ayush: { covered: null, notes: null, source_ref: null }, health_checkups: { covered: null, frequency_raw: null, limit_raw: null, source_ref: null }, vaccination: { covered: null, limit_raw: null, source_ref: null }, teleconsultation: { covered: null, limit_raw: null, source_ref: null }, restoration_or_reload: { available: null, type: null, conditions: null, usage_rules: null, source_ref: null }, no_claim_bonus: { available: null, accrual_raw: null, max_raw: null, reduction_rules: null, source_ref: null } },\n  exclusions: { standard_exclusions: [], product_specific_exclusions: [], permanent_exclusions_or_ped_exclusions: [], non_medical_items_consumables: { covered_or_excluded: null, notes: null, source_ref: null } },\n  claims_and_admin: { cashless_process: null, reimbursement_process: null, claim_intimation_timeline: null, document_submission_timeline: null, claim_settlement_timeline: null, free_look_period: null, renewal_and_grace_period: null, portability: null, migration: null, cancellation_refund: null, customer_support: { insurer_helpline: null, tpa_helpline: null, email: null, website: null, address: null } },\n  plan_variants: [],\n  notes: { missing_or_unclear: [], conflicts: [], assumptions: [], extraction_warnings: [] },\n  source_map: []\n};\n\nfunction mergeWithTemplate(template, data) {\n  if (Array.isArray(template)) {\n    return Array.isArray(data) ? data : [];\n  }\n  if (template && typeof template === 'object') {\n    const out = {};\n    const src = (data && typeof data === 'object') ? data : {};\n    for (const k of Object.keys(template)) out[k] = mergeWithTemplate(template[k], src[k]);\n    return out;\n  }\n  if (data === undefined) return template;\n  return data;\n}\n\nreturn $input.all().map((item) => {\n  const raw = item.json.policy_json ?? item.json.output ?? item.json.text ?? item.json.response ?? item.json.result ?? item.json;\n  const parsed = extractJson(raw);\n  const policy = mergeWithTemplate(TEMPLATE, parsed);\n  if (!policy.notes) policy.notes = { missing_or_unclear: [], conflicts: [], assumptions: [], extraction_warnings: [] };\n  if (!Array.isArray(policy.notes.missing_or_unclear)) policy.notes.missing_or_unclear = [];\n  if (!Array.isArray(policy.notes.conflicts)) policy.notes.conflicts = [];\n  if (!Array.isArray(policy.notes.assumptions)) policy.notes.assumptions = [];\n  if (!Array.isArray(policy.notes.extraction_warnings)) policy.notes.extraction_warnings = [];\n  return { json: { ...item.json, policy_json: policy } };\n});"
      },
      "id": "validator_repair",
      "name": "Validator/Repair",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2020,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item => ({ json: { status: 'ok', policy: item.json.policy_json || item.json, text_hash: item.json.text_hash } }));"
      },
      "id": "assemble_ok",
      "name": "Assemble Final Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        220
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.entrypoint}}",
                    "rightValue": "webhook",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "webhook"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.entrypoint}}",
                    "rightValue": "chat",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "chat"
            }
          ]
        },
        "fallbackOutput": "webhook"
      },
      "id": "entry_router",
      "name": "Entrypoint Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        2460,
        20
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$json.response_payload || $json}}",
        "options": {}
      },
      "id": "respond_webhook",
      "name": "Respond (Webhook)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2680,
        -80
      ]
    },
    {
      "parameters": {
        "text": "={{$json.status === 'needs_context' ? 'Need more context before deep extraction. Please answer:\\n' + ($json.questions || []).map((q,i)=>`${i+1}. ${q.question}`).join('\\n') : `Parsed policy. Insurer/Product: ${$json.policy?.policy_metadata?.insurer_name || 'n/a'} / ${$json.policy?.policy_metadata?.product_name || 'n/a'}; SI: ${$json.policy?.policy_metadata?.sum_insured?.raw || 'n/a'}; Waiting: ${$json.policy?.waiting_periods?.initial_waiting_period?.raw || 'n/a'}; Room rent: ${$json.policy?.limits_and_sublimits?.room_rent?.raw || 'n/a'}`}}"
      },
      "id": "respond_chat",
      "name": "Respond (Chat)",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2680,
        120
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "policy-context",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "context_webhook",
      "name": "Context Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1320,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = this.getWorkflowStaticData('global');\nreturn $input.all().map(item => {\n  const text_hash = item.json.body?.text_hash || item.json.text_hash;\n  const user_context = item.json.body?.user_context || item.json.user_context || {};\n  const pending = text_hash ? data[text_hash] : null;\n  if (!pending) {\n    return { json: { status: 'needs_file_resend', text_hash, message: 'No pending context found. Please resend file with user_context.' } };\n  }\n  return {\n    json: {\n      entrypoint: 'webhook',\n      file_meta: pending.file_meta || {},\n      binary_property_name: pending.binary_property_name || 'file',\n      extracted_text: pending.extracted_text || '',\n      scanner: { detected: pending.scanner || {} },\n      gap: {},\n      user_context,\n      policy_json: {},\n      text_hash\n    }\n  };\n});"
      },
      "id": "resume_router",
      "name": "Resume Router",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1080,
        420
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{$json.status}}",
              "rightValue": "needs_file_resend",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "resume_pending_if",
      "name": "Resume Pending? (IF)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -860,
        420
      ]
    }
  ],
  "connections": {
    "Webhook Upload": {
      "main": [
        [
          {
            "node": "Normalize Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Upload": {
      "main": [
        [
          {
            "node": "Normalize Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Binary": {
      "main": [
        [
          {
            "node": "File Type Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "File Type Router": {
      "main": [
        [
          {
            "node": "Extract Text (Built-in)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Text (Built-in)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Text (External)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text (Built-in)": {
      "main": [
        [
          {
            "node": "Merge Extracted Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text (External)": {
      "main": [
        [
          {
            "node": "Merge Extracted Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Extracted Text": {
      "main": [
        [
          {
            "node": "OCR Needed? (IF)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Needed? (IF)": {
      "main": [
        [
          {
            "node": "OCR Fallback",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Sanitize & Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Fallback": {
      "main": [
        [
          {
            "node": "Sanitize & Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitize & Hash": {
      "main": [
        [
          {
            "node": "Policy Scanner",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model (Scanner)": {
      "ai_languageModel": [
        [
          {
            "node": "Policy Scanner",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Scanner Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Policy Scanner",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Policy Scanner": {
      "main": [
        [
          {
            "node": "Context Gap Detector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model (Gap)": {
      "ai_languageModel": [
        [
          {
            "node": "Context Gap Detector",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Gap Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Context Gap Detector",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Context Gap Detector": {
      "main": [
        [
          {
            "node": "Needs Context? (IF)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Context? (IF)": {
      "main": [
        [
          {
            "node": "Store Pending Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Deep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Pending Context": {
      "main": [
        [
          {
            "node": "Assemble Needs Context Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Assemble Needs Context Response": {
      "main": [
        [
          {
            "node": "Entrypoint Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model (Deep)": {
      "ai_languageModel": [
        [
          {
            "node": "Deep Extractor",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Deep Extractor": {
      "main": [
        [
          {
            "node": "Validator/Repair",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validator/Repair": {
      "main": [
        [
          {
            "node": "Assemble Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Assemble Final Response": {
      "main": [
        [
          {
            "node": "Entrypoint Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Entrypoint Router": {
      "main": [
        [
          {
            "node": "Respond (Webhook)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond (Chat)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Context Webhook": {
      "main": [
        [
          {
            "node": "Resume Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resume Router": {
      "main": [
        [
          {
            "node": "Resume Pending? (IF)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resume Pending? (IF)": {
      "main": [
        [
          {
            "node": "Respond (Webhook)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Deep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "india-health-policy-parser-multi-agent-cloud-v1",
  "meta": {
    "templateCredsSetupCompleted": false
  },
  "id": "IndiaHealthPolicyParserMultiAgentCloud",
  "tags": []
}