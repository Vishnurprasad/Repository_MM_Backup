{
  "name": "India Health Policy Parser - Multi Agent (Cloud)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "policy-upload",
        "responseMode": "responseNode",
        "options": {
          "binaryData": true
        }
      },
      "id": "webhook_upload",
      "name": "Webhook Upload",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1320,
        -180
      ]
    },
    {
      "parameters": {
        "options": {
          "allowFileUploads": true
        }
      },
      "id": "chat_upload",
      "name": "Chat Upload",
      "type": "n8n-nodes-base.chatTrigger",
      "typeVersion": 1.1,
      "position": [
        -1320,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const out = [];\nfor (const item of $input.all()) {\n  const j = item.json || {};\n  const b = item.binary || {};\n  const fromWebhook = !!j.headers;\n  const fromChat = !fromWebhook;\n\n  let binaryPropertyName = 'file';\n  if (!b.file) {\n    const firstKey = Object.keys(b)[0];\n    if (firstKey) binaryPropertyName = firstKey;\n  }\n\n  const bin = b[binaryPropertyName] || {};\n  const filename = bin.fileName || bin.fileName || j.fileName || null;\n  const mime = bin.mimeType || j.mimeType || 'application/octet-stream';\n  const size = bin.fileSize || null;\n\n  out.push({\n    json: {\n      entrypoint: fromWebhook ? 'webhook' : 'chat',\n      file_meta: { filename, mime, size },\n      binary_property_name: binaryPropertyName,\n      extracted_text: null,\n      scanner: {},\n      gap: {},\n      user_context: j.user_context || {},\n      policy_json: {},\n      text_hash: null\n    },\n    binary: b\n  });\n}\nreturn out;"
      },
      "id": "normalize_binary",
      "name": "Normalize Binary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1080,
        -40
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.file_meta.mime}}",
                    "rightValue": "pdf",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "pdf"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.file_meta.mime + ' ' + ($json.file_meta.filename || '')}}",
                    "rightValue": "docx",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "docx"
            }
          ]
        },
        "fallbackOutput": "other"
      },
      "id": "filetype_router",
      "name": "File Type Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -860,
        -40
      ]
    },
    {
      "parameters": {
        "operation": "pdf",
        "binaryPropertyName": "={{$json.binary_property_name}}"
      },
      "id": "extract_built_in",
      "name": "Extract Text (Built-in)",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -620,
        -180
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$json.file_meta.mime && $json.file_meta.mime.includes('pdf') ? $env.PDF_TEXT_EXTRACT_URL : $env.DOCX_TEXT_EXTRACT_URL}}",
        "sendBinaryData": true,
        "binaryPropertyName": "={{$json.binary_property_name}}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "extract_external",
      "name": "Extract Text (External)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -620,
        40
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map((item) => {\n  const j = item.json || {};\n  const textCandidate = j.text || j.data?.text || j.extractedText || j.extracted_text || '';\n  const extracted_text = String(textCandidate || '').trim();\n  return {\n    json: { ...j, extracted_text },\n    binary: item.binary\n  };\n});"
      },
      "id": "merge_extracted",
      "name": "Merge Extracted Text",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -380,
        -40
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "short-text",
              "leftValue": "={{($json.extracted_text || '').length}}",
              "rightValue": 500,
              "operator": {
                "type": "number",
                "operation": "smaller"
              }
            }
          ],
          "combinator": "or"
        }
      },
      "id": "ocr_length_if",
      "name": "OCR Needed? (IF)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -180,
        -40
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.OCR_EXTRACT_URL}}",
        "sendBinaryData": true,
        "binaryPropertyName": "={{$json.binary_property_name}}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "ocr_fallback",
      "name": "OCR Fallback",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        20,
        -160
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nfunction sanitize(text) {\n  const lines = String(text || '').split(/\\r?\\n/).map(l => l.trim()).filter(Boolean);\n  const freq = new Map();\n  for (const l of lines) freq.set(l, (freq.get(l) || 0) + 1);\n  const filtered = lines.filter(l => (freq.get(l) || 0) < 6);\n  return filtered.join('\\n').replace(/[\\t ]+/g, ' ').replace(/\\n{3,}/g, '\\n\\n').trim();\n}\n\nreturn $input.all().map((item) => {\n  const j = item.json || {};\n  const ocrText = j.text || j.data?.text || '';\n  const baseText = j.extracted_text || '';\n  const chosen = String(ocrText || baseText || '');\n  const cleaned = sanitize(chosen);\n  const capped = cleaned.slice(0, 120000);\n  const first_12000_chars = capped.slice(0, 12000);\n  const text_hash = crypto.createHash('sha256').update(capped).digest('hex');\n  return {\n    json: {\n      ...j,\n      extracted_text: capped,\n      first_12000_chars,\n      text_hash\n    },\n    binary: item.binary\n  };\n});"
      },
      "id": "sanitize_hash",
      "name": "Sanitize & Hash",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        240,
        -40
      ]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1
        }
      },
      "id": "openai_chat_model_scanner",
      "name": "OpenAI Chat Model (Scanner)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        460,
        -260
      ],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "You are Policy Scanner (India). Input: first_12000_chars and file_meta. Return STRICT JSON only following the required schema.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Extract only what is present. Unknown => null. Country must be India."
        }
      },
      "id": "policy_scanner",
      "name": "Policy Scanner",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        680,
        -40
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"detected\": {\n    \"is_health_insurance\": null,\n    \"country\": \"India\",\n    \"document_type\": null,\n    \"insurer_name\": null,\n    \"product_name\": null,\n    \"uin\": null,\n    \"plan_names_found\": [],\n    \"sum_insured_options_found\": [],\n    \"has_family_floater_terms\": null,\n    \"has_zone_terms\": null,\n    \"riders_or_addons_mentioned\": [],\n    \"key_sections_found\": {\n      \"waiting_periods\": null,\n      \"room_rent\": null,\n      \"pre_post_hosp\": null,\n      \"exclusions\": null\n    }\n  },\n  \"evidence\": [\n    { \"field\": null, \"snippet\": null, \"source_ref\": null }\n  ],\n  \"confidence\": { \"overall\": null, \"notes\": null }\n}"
      },
      "id": "scanner_parser",
      "name": "Scanner Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        680,
        -260
      ]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1
        }
      },
      "id": "openai_chat_model_gap",
      "name": "OpenAI Chat Model (Gap)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        920,
        -260
      ],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "You are Context Gap Detector. Ask minimum ranked questions only if needed.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Use scanner output and user_context. Output strict JSON only."
        }
      },
      "id": "context_gap_detector",
      "name": "Context Gap Detector",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1140,
        -40
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"need_user_input\": null,\n  \"questions\": [\n    {\n      \"id\": null,\n      \"question\": null,\n      \"type\": \"single_select|multi_select|text|number|object\",\n      \"options\": [],\n      \"required\": null,\n      \"reason\": null\n    }\n  ],\n  \"assumptions_if_unanswered\": [\n    { \"field\": null, \"assumption\": null, \"risk\": \"low|medium|high\" }\n  ],\n  \"stop_condition\": \"ask_questions_then_resume|continue\"\n}"
      },
      "id": "gap_parser",
      "name": "Gap Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        1140,
        -260
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{$json.need_user_input}}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "needs_context_if",
      "name": "Needs Context? (IF)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1360,
        -40
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = this.getWorkflowStaticData('global');\nfor (const item of $input.all()) {\n  const key = item.json.text_hash;\n  if (key) {\n    data[key] = {\n      extracted_text: item.json.extracted_text,\n      file_meta: item.json.file_meta,\n      scanner: item.json.detected || item.json.scanner?.detected || {},\n      binary_property_name: item.json.binary_property_name,\n      saved_at: new Date().toISOString()\n    };\n  }\n}\nreturn $input.all();"
      },
      "id": "store_pending",
      "name": "Store Pending Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1580,
        -180
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map((item)=>{\n  const questions = item.json.questions || [];\n  const payload = {\n    status: 'needs_context',\n    questions,\n    detected: item.json.detected || {},\n    text_hash: item.json.text_hash\n  };\n  return {json: {...item.json, response_payload: payload}};\n});"
      },
      "id": "assemble_needs_context",
      "name": "Assemble Needs Context Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        -180
      ]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1
        }
      },
      "id": "openai_chat_model_deep",
      "name": "OpenAI Chat Model (Deep)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        1580,
        220
      ],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Deep Extractor (India Policy -> Schema JSON). Use full extracted_text + scanner + user_context. Return STRICT JSON matching exact schema.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "No hallucination. Unknown null. Keep source_ref snippets where possible."
        }
      },
      "id": "deep_extractor",
      "name": "Deep Extractor",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1800,
        220
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"document_classification\": {\n    \"is_health_insurance\": null,\n    \"india_market\": true,\n    \"document_type\": null,\n    \"confidence\": { \"overall\": null, \"rationale\": null }\n  },\n  \"policy_metadata\": {\n    \"insurer_name\": null,\n    \"product_name\": null,\n    \"uin\": null,\n    \"plan_name\": null,\n    \"policy_type\": null,\n    \"individual_or_floater\": null,\n    \"policy_number\": null,\n    \"certificate_number\": null,\n    \"tpa_name\": null,\n    \"network\": {\n      \"cashless_available\": null,\n      \"network_name_or_partner\": null,\n      \"non_network_reimbursement_allowed\": null\n    },\n    \"policy_period\": { \"start_date\": null, \"end_date\": null },\n    \"geography\": { \"zone_or_city_tier\": null, \"india_state\": null, \"city\": null },\n    \"sum_insured\": { \"raw\": null, \"amount\": null, \"currency\": \"INR\", \"type\": null },\n    \"insured_members\": { \"count\": null, \"relationships\": null, \"entry_age_rules\": null }\n  },\n  \"premium_and_tax\": {\n    \"premium\": { \"raw\": null, \"amount\": null, \"currency\": \"INR\", \"frequency\": null },\n    \"gst_or_taxes\": { \"raw\": null, \"rate\": null },\n    \"loadings_or_discounts\": [\n      { \"type\": null, \"value\": null, \"conditions\": null, \"source_ref\": null }\n    ]\n  },\n  \"cost_sharing\": {\n    \"deductible\": { \"raw\": null, \"amount\": null, \"currency\": \"INR\", \"per\": null, \"notes\": null },\n    \"co_pay\": [\n      { \"trigger\": null, \"raw\": null, \"rate\": null, \"cap\": null, \"notes\": null, \"source_ref\": null }\n    ],\n    \"coinsurance\": [\n      { \"service\": null, \"raw\": null, \"rate\": null, \"notes\": null, \"source_ref\": null }\n    ]\n  },\n  \"waiting_periods\": {\n    \"initial_waiting_period\": { \"raw\": null, \"accident_exception\": null, \"source_ref\": null },\n    \"ped_waiting_period\": { \"raw\": null, \"definition_of_ped\": null, \"source_ref\": null },\n    \"maternity_waiting_period\": { \"raw\": null, \"source_ref\": null },\n    \"specific_disease_waiting_periods\": [\n      { \"condition_or_procedure\": null, \"raw\": null, \"source_ref\": null }\n    ]\n  },\n  \"limits_and_sublimits\": {\n    \"room_rent\": { \"raw\": null, \"type\": null, \"notes\": null, \"source_ref\": null },\n    \"icu_rent\": { \"raw\": null, \"type\": null, \"notes\": null, \"source_ref\": null },\n    \"procedure_or_disease_sublimits\": [\n      { \"item\": null, \"limit_raw\": null, \"notes\": null, \"source_ref\": null }\n    ],\n    \"ambulance_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"ayush_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"cataract_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"opd_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"annual_or_lifetime_limits\": [\n      { \"benefit\": null, \"limit_raw\": null, \"source_ref\": null }\n    ]\n  },\n  \"benefits\": {\n    \"hospitalization_inpatient\": { \"covered\": null, \"notes\": null, \"source_ref\": null },\n    \"pre_hospitalization\": { \"covered\": null, \"duration_raw\": null, \"source_ref\": null },\n    \"post_hospitalization\": { \"covered\": null, \"duration_raw\": null, \"source_ref\": null },\n    \"daycare\": { \"covered\": null, \"definition_or_list\": null, \"source_ref\": null },\n    \"domiciliary_hospitalization\": { \"covered\": null, \"conditions\": null, \"source_ref\": null },\n    \"modern_treatments\": { \"covered\": null, \"limits_or_list\": null, \"source_ref\": null },\n    \"organ_donor\": { \"covered\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"maternity\": {\n      \"covered\": null,\n      \"limit_raw\": null,\n      \"newborn_covered\": null,\n      \"newborn_waiting_or_conditions\": null,\n      \"source_ref\": null\n    },\n    \"mental_health\": { \"covered\": null, \"notes\": null, \"source_ref\": null },\n    \"ayush\": { \"covered\": null, \"notes\": null, \"source_ref\": null },\n    \"health_checkups\": { \"covered\": null, \"frequency_raw\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"vaccination\": { \"covered\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"teleconsultation\": { \"covered\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"restoration_or_reload\": {\n      \"available\": null,\n      \"type\": null,\n      \"conditions\": null,\n      \"usage_rules\": null,\n      \"source_ref\": null\n    },\n    \"no_claim_bonus\": {\n      \"available\": null,\n      \"accrual_raw\": null,\n      \"max_raw\": null,\n      \"reduction_rules\": null,\n      \"source_ref\": null\n    }\n  },\n  \"exclusions\": {\n    \"standard_exclusions\": [],\n    \"product_specific_exclusions\": [\n      { \"exclusion\": null, \"source_ref\": null }\n    ],\n    \"permanent_exclusions_or_ped_exclusions\": [\n      { \"item\": null, \"source_ref\": null }\n    ],\n    \"non_medical_items_consumables\": { \"covered_or_excluded\": null, \"notes\": null, \"source_ref\": null }\n  },\n  \"claims_and_admin\": {\n    \"cashless_process\": null,\n    \"reimbursement_process\": null,\n    \"claim_intimation_timeline\": null,\n    \"document_submission_timeline\": null,\n    \"claim_settlement_timeline\": null,\n    \"free_look_period\": null,\n    \"renewal_and_grace_period\": null,\n    \"portability\": null,\n    \"migration\": null,\n    \"cancellation_refund\": null,\n    \"customer_support\": {\n      \"insurer_helpline\": null,\n      \"tpa_helpline\": null,\n      \"email\": null,\n      \"website\": null,\n      \"address\": null\n    }\n  },\n  \"plan_variants\": [\n    {\n      \"variant_name\": null,\n      \"variant_identifier\": null,\n      \"sum_insured_options\": null,\n      \"cost_sharing_overrides\": null,\n      \"limits_overrides\": null,\n      \"benefit_overrides\": null,\n      \"waiting_period_overrides\": null,\n      \"notes\": null\n    }\n  ],\n  \"notes\": {\n    \"missing_or_unclear\": [],\n    \"conflicts\": [],\n    \"assumptions\": [],\n    \"extraction_warnings\": []\n  },\n  \"source_map\": [\n    {\n      \"field_path\": null,\n      \"evidence_snippet\": null,\n      \"source_ref\": null\n    }\n  ]\n}"
      },
      "id": "deep_parser",
      "name": "Deep Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        1800,
        20
      ]
    },
    {
      "parameters": {
        "jsCode": "function ensure(obj, key, defVal){ if(!(key in obj)) obj[key]=defVal; }\nreturn $input.all().map((item)=>{\n  const p = typeof item.json === 'string' ? JSON.parse(item.json) : (item.json.policy_json || item.json);\n  ensure(p, 'notes', {});\n  ensure(p.notes, 'missing_or_unclear', []);\n  ensure(p.notes, 'conflicts', []);\n  ensure(p.notes, 'assumptions', []);\n  ensure(p.notes, 'extraction_warnings', []);\n  return {json: {...item.json, policy_json: p}};\n});"
      },
      "id": "validator_repair",
      "name": "Validator/Repair",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2020,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item => ({ json: { status: 'ok', policy: item.json.policy_json || item.json, text_hash: item.json.text_hash } }));"
      },
      "id": "assemble_ok",
      "name": "Assemble Final Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        220
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.entrypoint}}",
                    "rightValue": "webhook",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "webhook"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.entrypoint}}",
                    "rightValue": "chat",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "chat"
            }
          ]
        },
        "fallbackOutput": "webhook"
      },
      "id": "entry_router",
      "name": "Entrypoint Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        2460,
        20
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$json.response_payload || $json}}",
        "options": {}
      },
      "id": "respond_webhook",
      "name": "Respond (Webhook)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2680,
        -80
      ]
    },
    {
      "parameters": {
        "text": "={{$json.status === 'needs_context' ? 'Need more context before deep extraction. Please answer:\\n' + ($json.questions || []).map((q,i)=>`${i+1}. ${q.question}`).join('\\n') : `Parsed policy. Insurer/Product: ${$json.policy?.policy_metadata?.insurer_name || 'n/a'} / ${$json.policy?.policy_metadata?.product_name || 'n/a'}; SI: ${$json.policy?.policy_metadata?.sum_insured?.raw || 'n/a'}; Waiting: ${$json.policy?.waiting_periods?.initial_waiting_period?.raw || 'n/a'}; Room rent: ${$json.policy?.limits_and_sublimits?.room_rent?.raw || 'n/a'}`}}"
      },
      "id": "respond_chat",
      "name": "Respond (Chat)",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2680,
        120
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "policy-context",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "context_webhook",
      "name": "Context Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1320,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = this.getWorkflowStaticData('global');\nreturn $input.all().map(item => {\n  const text_hash = item.json.body?.text_hash || item.json.text_hash;\n  const user_context = item.json.body?.user_context || item.json.user_context || {};\n  const pending = text_hash ? data[text_hash] : null;\n  if (!pending) {\n    return { json: { status: 'needs_file_resend', text_hash, message: 'No pending context found. Please resend file with user_context.' } };\n  }\n  return {\n    json: {\n      entrypoint: 'webhook',\n      file_meta: pending.file_meta || {},\n      binary_property_name: pending.binary_property_name || 'file',\n      extracted_text: pending.extracted_text || '',\n      scanner: { detected: pending.scanner || {} },\n      gap: {},\n      user_context,\n      policy_json: {},\n      text_hash\n    }\n  };\n});"
      },
      "id": "resume_router",
      "name": "Resume Router",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1080,
        420
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{$json.status}}",
              "rightValue": "needs_file_resend",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "resume_pending_if",
      "name": "Resume Pending? (IF)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -860,
        420
      ]
    }
  ],
  "connections": {
    "Webhook Upload": {
      "main": [
        [
          {
            "node": "Normalize Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Upload": {
      "main": [
        [
          {
            "node": "Normalize Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Binary": {
      "main": [
        [
          {
            "node": "File Type Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "File Type Router": {
      "main": [
        [
          {
            "node": "Extract Text (Built-in)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Text (Built-in)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Text (External)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text (Built-in)": {
      "main": [
        [
          {
            "node": "Merge Extracted Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text (External)": {
      "main": [
        [
          {
            "node": "Merge Extracted Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Extracted Text": {
      "main": [
        [
          {
            "node": "OCR Needed? (IF)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Needed? (IF)": {
      "main": [
        [
          {
            "node": "OCR Fallback",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Sanitize & Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Fallback": {
      "main": [
        [
          {
            "node": "Sanitize & Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitize & Hash": {
      "main": [
        [
          {
            "node": "Policy Scanner",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model (Scanner)": {
      "ai_languageModel": [
        [
          {
            "node": "Policy Scanner",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Scanner Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Policy Scanner",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Policy Scanner": {
      "main": [
        [
          {
            "node": "Context Gap Detector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model (Gap)": {
      "ai_languageModel": [
        [
          {
            "node": "Context Gap Detector",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Gap Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Context Gap Detector",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Context Gap Detector": {
      "main": [
        [
          {
            "node": "Needs Context? (IF)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Context? (IF)": {
      "main": [
        [
          {
            "node": "Store Pending Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Deep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Pending Context": {
      "main": [
        [
          {
            "node": "Assemble Needs Context Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Assemble Needs Context Response": {
      "main": [
        [
          {
            "node": "Entrypoint Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model (Deep)": {
      "ai_languageModel": [
        [
          {
            "node": "Deep Extractor",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Deep Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Deep Extractor",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Deep Extractor": {
      "main": [
        [
          {
            "node": "Validator/Repair",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validator/Repair": {
      "main": [
        [
          {
            "node": "Assemble Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Assemble Final Response": {
      "main": [
        [
          {
            "node": "Entrypoint Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Entrypoint Router": {
      "main": [
        [
          {
            "node": "Respond (Webhook)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond (Chat)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Context Webhook": {
      "main": [
        [
          {
            "node": "Resume Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resume Router": {
      "main": [
        [
          {
            "node": "Resume Pending? (IF)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resume Pending? (IF)": {
      "main": [
        [
          {
            "node": "Respond (Webhook)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Deep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "india-health-policy-parser-multi-agent-cloud-v1",
  "meta": {
    "templateCredsSetupCompleted": false
  },
  "id": "IndiaHealthPolicyParserMultiAgentCloud",
  "tags": []
}