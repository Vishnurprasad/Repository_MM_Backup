{
  "name": "India Health Policy Analyzer - Expert Architecture (Cloud v2.4.6)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "policy-upload",
        "responseMode": "responseNode",
        "options": {
          "binaryData": true
        }
      },
      "id": "webhook_upload",
      "name": "Webhook Upload",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1320,
        -180
      ]
    },
    {
      "parameters": {
        "options": {
          "allowFileUploads": true
        },
        "responseMode": "lastNode"
      },
      "id": "chat_upload",
      "name": "Chat Upload",
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.0,
      "position": [
        -1320,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "const out = [];\nfor (const item of $input.all()) {\n  const j = item.json || {};\n  const b = item.binary || {};\n  const fromWebhook = !!j.headers;\n  const fromChat = !fromWebhook;\n\n  let binaryPropertyName = 'file';\n  if (!b.file) {\n    const firstKey = Object.keys(b)[0];\n    if (firstKey) binaryPropertyName = firstKey;\n  }\n\n  const bin = b[binaryPropertyName] || {};\n  const filename = bin.fileName || bin.file_name || bin.filename || j.fileName || j.file_name || j.filename || null;\n  let mime = bin.mimeType || bin.mime_type || j.mimeType || j.mime_type || null;\n  if (!mime && filename) {\n    const lower = String(filename).toLowerCase();\n    if (lower.endsWith('.pdf')) mime = 'application/pdf';\n    else if (lower.endsWith('.docx')) mime = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n  }\n  if (!mime) mime = 'application/octet-stream';\n  const size = bin.fileSize || null;\n\n  out.push({\n    json: {\n      entrypoint: fromWebhook ? 'webhook' : 'chat',\n      file_meta: { filename, mime, size },\n      binary_property_name: binaryPropertyName,\n      extracted_text: null,\n      scanner: {},\n      gap: {},\n      user_context: j.user_context || {},\n      policy_json: {},\n      text_hash: null\n    },\n    binary: b\n  });\n}\nreturn out;"
      },
      "id": "normalize_binary",
      "name": "Normalize Binary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1080,
        -40
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.file_meta.mime + ' ' + ($json.file_meta.filename || '')}}",
                    "rightValue": "pdf",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "pdf"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.file_meta.mime + ' ' + ($json.file_meta.filename || '')}}",
                    "rightValue": "docx",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "docx"
            }
          ]
        },
        "fallbackOutput": "other"
      },
      "id": "filetype_router",
      "name": "File Type Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -860,
        -40
      ]
    },
    {
      "parameters": {
        "operation": "pdf",
        "binaryPropertyName": "={{$json.binary_property_name}}"
      },
      "id": "extract_built_in",
      "name": "Extract Text (Built-in)",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -620,
        -180
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$json.file_meta.mime && $json.file_meta.mime.includes('pdf') ? $env.PDF_TEXT_EXTRACT_URL : $env.DOCX_TEXT_EXTRACT_URL}}",
        "sendBinaryData": true,
        "binaryPropertyName": "={{$json.binary_property_name}}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "extract_external",
      "name": "Extract Text (External)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -620,
        40
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map((item) => {\n  const j = item.json || {};\n  const textCandidate = j.text || j.data?.text || j.extractedText || j.extracted_text || '';\n  const extracted_text = String(textCandidate || '').trim();\n  return {\n    json: { ...j, extracted_text },\n    binary: item.binary\n  };\n});"
      },
      "id": "merge_extracted",
      "name": "Merge Extracted Text",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -380,
        -40
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "short-text",
              "leftValue": "={{($json.extracted_text || '').length}}",
              "rightValue": 500,
              "operator": {
                "type": "number",
                "operation": "smaller"
              }
            }
          ],
          "combinator": "or"
        }
      },
      "id": "ocr_length_if",
      "name": "OCR Needed? (IF)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -180,
        -40
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.OCR_EXTRACT_URL}}",
        "sendBinaryData": true,
        "binaryPropertyName": "={{$json.binary_property_name}}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "ocr_fallback",
      "name": "OCR Fallback",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        20,
        -160
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nfunction sanitize(text) {\n  const lines = String(text || '').split(/\\r?\\n/).map(l => l.trim()).filter(Boolean);\n  const freq = new Map();\n  for (const l of lines) freq.set(l, (freq.get(l) || 0) + 1);\n  const filtered = lines.filter(l => (freq.get(l) || 0) < 6);\n  return filtered.join('\\n').replace(/[\\t ]+/g, ' ').replace(/\\n{3,}/g, '\\n\\n').trim();\n}\n\nreturn $input.all().map((item) => {\n  const j = item.json || {};\n  const ocrText = j.text || j.data?.text || '';\n  const baseText = j.extracted_text || '';\n  const chosen = (ocrText && ocrText.length > baseText.length * 0.6) ? ocrText : baseText;\n  const cleaned = sanitize(chosen);\n  const extracted_text = cleaned.slice(0, 120000);\n  const first_25000_chars = extracted_text.slice(0, 25000);\n  const text_hash = crypto.createHash('sha256').update(extracted_text, 'utf8').digest('hex');\n  return {\n    json: {\n      ...j,\n      extracted_text,\n      first_25000_chars,\n      text_hash\n    },\n    binary: item.binary\n  };\n});"
      },
      "id": "sanitize_hash",
      "name": "Sanitize & Hash",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        240,
        -40
      ]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1
        }
      },
      "id": "openai_chat_model_scanner",
      "name": "OpenAI Chat Model (Scanner)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        460,
        -260
      ],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "You are the Policy Scanner Agent for Indian health insurance documents.\n\nYour job is NOT to fully extract benefits.\n\nYour job is to quickly scan the document and identify high-level anchors\nthat help downstream agents interpret the policy correctly.\n\nYou must ONLY detect information that is explicitly present in the text.\n\nIf something is unclear or not present, return null.\n\n--------------------------------------------------\nINPUTS\n--------------------------------------------------\n\nFILE_META:\n{{$json.file_meta}}\n\nDOCUMENT TEXT:\n{{$json.first_25000_chars}}\n\n--------------------------------------------------\nWHAT YOU MUST DO\n--------------------------------------------------\n\n1) Classify the document:\n\n- Is this a health insurance policy?\n- Identify document type:\n  - policy wording\n  - schedule of benefits\n  - certificate of insurance\n  - brochure\n  - claim letter\n  - unknown\n\n2) Identify policy anchors:\n\n- insurer name\n- product name\n- UIN (if present)\n- plan names or variants mentioned\n- sum insured options mentioned\n- whether family floater terms appear\n- whether zone/geography terms appear\n- riders/add-ons mentioned\n\n3) Detect presence (NOT details) of key sections:\n\n- waiting periods\n- room rent rules\n- pre/post hospitalization\n- exclusions\n\n4) Provide evidence snippets where possible.\n\n--------------------------------------------------\nIMPORTANT RULES (INDIA HEALTH INSURANCE)\n--------------------------------------------------\n\n- Indian policies often include multiple plan variants and sum insured tables.\n- Policy wording may contain generic limits \u2014 do not assume selected values.\n- Schedule or certificate sections override wording if clearly identified.\n\n--------------------------------------------------\nOUTPUT RULES\n--------------------------------------------------\n\n- Return STRICT JSON ONLY.\n- Do not include explanations outside JSON.\n- Unknown values MUST be null.\n- Never hallucinate.\n\nDOCUMENT CLASSIFIER:\n{{$json.classifier}}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Extract only what is present. Unknown => null. Country must be India."
        }
      },
      "id": "policy_scanner",
      "name": "Policy Scanner",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        680,
        -40
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"detected\": {\n    \"is_health_insurance\": null,\n    \"country\": \"India\",\n    \"document_type\": \"unknown\",\n    \"insurer_name\": null,\n    \"product_name\": null,\n    \"uin\": null,\n    \"plan_names_found\": [\"example\"],\n    \"sum_insured_options_found\": [\"example\"],\n    \"has_family_floater_terms\": null,\n    \"has_zone_terms\": null,\n    \"riders_or_addons_mentioned\": [\"example\"],\n    \"key_sections_found\": {\n      \"waiting_periods\": null,\n      \"room_rent\": null,\n      \"pre_post_hosp\": null,\n      \"exclusions\": null\n    }\n  },\n  \"allowed_document_types\": [\n    \"policy wording\",\n    \"schedule of benefits\",\n    \"certificate of insurance\",\n    \"brochure\",\n    \"claim letter\",\n    \"unknown\"\n  ],\n  \"evidence\": [\n    { \"field\": null, \"snippet\": null, \"source_ref\": null }\n  ],\n  \"confidence\": { \"overall\": null, \"notes\": null }\n}"
      },
      "id": "scanner_parser",
      "name": "Scanner Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        680,
        -260
      ]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1
        }
      },
      "id": "openai_chat_model_gap",
      "name": "OpenAI Chat Model (Gap)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        920,
        -260
      ],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "You are Context Gap Detector.\n\nDOCUMENT CLASSIFIER:\n{{$json.classifier}}\n\nSCANNER OUTPUT:\n{{$json.scanner.detected}}\n\nUSER CONTEXT:\n{{$json.user_context}}\n\nAsk minimum ranked questions only if needed. Return strict JSON only.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Use scanner output and user_context. Output strict JSON only."
        }
      },
      "id": "context_gap_detector",
      "name": "Context Gap Detector",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1140,
        -40
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"need_user_input\": null,\n  \"questions\": [\n    {\n      \"id\": null,\n      \"question\": null,\n      \"type\": \"single_select|multi_select|text|number|object\",\n      \"options\": [\"option\"],\n      \"required\": null,\n      \"reason\": null\n    }\n  ],\n  \"assumptions_if_unanswered\": [\n    { \"field\": null, \"assumption\": null, \"risk\": \"low|medium|high\" }\n  ],\n  \"stop_condition\": \"ask_questions_then_resume|continue\"\n}"
      },
      "id": "gap_parser",
      "name": "Gap Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        1140,
        -260
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{$json.need_user_input === true || $json.gap?.need_user_input === true}}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "needs_context_if",
      "name": "Needs Context? (IF)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1360,
        -40
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = this.getWorkflowStaticData('global');\nfor (const item of $input.all()) {\n  const key = item.json.text_hash;\n  if (key) {\n    data[key] = {\n      extracted_text: item.json.extracted_text,\n      file_meta: item.json.file_meta,\n      scanner: item.json.scanner?.detected || item.json.detected || {},\n      binary_property_name: item.json.binary_property_name,\n      saved_at: new Date().toISOString()\n    };\n  }\n}\nreturn $input.all();"
      },
      "id": "store_pending",
      "name": "Store Pending Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1580,
        -180
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map((item)=>{\n  const questions = item.json.gap?.questions || item.json.questions || [];\n  const payload = {\n    status: 'needs_context',\n    questions,\n    detected: item.json.scanner?.detected || item.json.detected || {},\n    text_hash: item.json.text_hash\n  };\n  return {json: {...item.json, response_payload: payload}};\n});"
      },
      "id": "assemble_needs_context",
      "name": "Assemble Needs Context Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        -180
      ]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1
        }
      },
      "id": "openai_chat_model_deep",
      "name": "OpenAI Chat Model (Deep)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        1580,
        220
      ],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Deep Extractor (India Policy -> Schema JSON).\n\nFILE_META:\n{{$json.file_meta}}\n\nSCANNER:\n{{$json.scanner.detected}}\n\nUSER_CONTEXT:\n{{$json.user_context}}\n\nDOCUMENT TEXT:\n{{$json.extracted_text}}\n\nReturn STRICT JSON only matching the required schema.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "No hallucination. Unknown null. Use exact keys/types from schema. Output JSON only."
        }
      },
      "id": "deep_extractor",
      "name": "Deep Extractor",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1800,
        220
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"document_classification\": {\n    \"is_health_insurance\": null,\n    \"india_market\": true,\n    \"document_type\": null,\n    \"confidence\": { \"overall\": null, \"rationale\": null }\n  },\n  \"policy_metadata\": {\n    \"insurer_name\": null,\n    \"product_name\": null,\n    \"uin\": null,\n    \"plan_name\": null,\n    \"policy_type\": null,\n    \"individual_or_floater\": null,\n    \"policy_number\": null,\n    \"certificate_number\": null,\n    \"tpa_name\": null,\n    \"network\": {\n      \"cashless_available\": null,\n      \"network_name_or_partner\": null,\n      \"non_network_reimbursement_allowed\": null\n    },\n    \"policy_period\": { \"start_date\": null, \"end_date\": null },\n    \"geography\": { \"zone_or_city_tier\": null, \"india_state\": null, \"city\": null },\n    \"sum_insured\": { \"raw\": null, \"amount\": null, \"currency\": \"INR\", \"type\": null },\n    \"insured_members\": { \"count\": null, \"relationships\": null, \"entry_age_rules\": null }\n  },\n  \"premium_and_tax\": {\n    \"premium\": { \"raw\": null, \"amount\": null, \"currency\": \"INR\", \"frequency\": null },\n    \"gst_or_taxes\": { \"raw\": null, \"rate\": null },\n    \"loadings_or_discounts\": [\n      { \"type\": null, \"value\": null, \"conditions\": null, \"source_ref\": null }\n    ]\n  },\n  \"cost_sharing\": {\n    \"deductible\": { \"raw\": null, \"amount\": null, \"currency\": \"INR\", \"per\": null, \"notes\": null },\n    \"co_pay\": [\n      { \"trigger\": null, \"raw\": null, \"rate\": null, \"cap\": null, \"notes\": null, \"source_ref\": null }\n    ],\n    \"coinsurance\": [\n      { \"service\": null, \"raw\": null, \"rate\": null, \"notes\": null, \"source_ref\": null }\n    ]\n  },\n  \"waiting_periods\": {\n    \"initial_waiting_period\": { \"raw\": null, \"accident_exception\": null, \"source_ref\": null },\n    \"ped_waiting_period\": { \"raw\": null, \"definition_of_ped\": null, \"source_ref\": null },\n    \"maternity_waiting_period\": { \"raw\": null, \"source_ref\": null },\n    \"specific_disease_waiting_periods\": [\n      { \"condition_or_procedure\": null, \"raw\": null, \"source_ref\": null }\n    ]\n  },\n  \"limits_and_sublimits\": {\n    \"room_rent\": { \"raw\": null, \"type\": null, \"notes\": null, \"source_ref\": null },\n    \"icu_rent\": { \"raw\": null, \"type\": null, \"notes\": null, \"source_ref\": null },\n    \"procedure_or_disease_sublimits\": [\n      { \"item\": null, \"limit_raw\": null, \"notes\": null, \"source_ref\": null }\n    ],\n    \"ambulance_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"ayush_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"cataract_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"opd_limit\": { \"limit_raw\": null, \"source_ref\": null },\n    \"annual_or_lifetime_limits\": [\n      { \"benefit\": null, \"limit_raw\": null, \"source_ref\": null }\n    ]\n  },\n  \"benefits\": {\n    \"hospitalization_inpatient\": { \"covered\": null, \"notes\": null, \"source_ref\": null },\n    \"pre_hospitalization\": { \"covered\": null, \"duration_raw\": null, \"source_ref\": null },\n    \"post_hospitalization\": { \"covered\": null, \"duration_raw\": null, \"source_ref\": null },\n    \"daycare\": { \"covered\": null, \"definition_or_list\": null, \"source_ref\": null },\n    \"domiciliary_hospitalization\": { \"covered\": null, \"conditions\": null, \"source_ref\": null },\n    \"modern_treatments\": { \"covered\": null, \"limits_or_list\": null, \"source_ref\": null },\n    \"organ_donor\": { \"covered\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"maternity\": {\n      \"covered\": null,\n      \"limit_raw\": null,\n      \"newborn_covered\": null,\n      \"newborn_waiting_or_conditions\": null,\n      \"source_ref\": null\n    },\n    \"mental_health\": { \"covered\": null, \"notes\": null, \"source_ref\": null },\n    \"ayush\": { \"covered\": null, \"notes\": null, \"source_ref\": null },\n    \"health_checkups\": { \"covered\": null, \"frequency_raw\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"vaccination\": { \"covered\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"teleconsultation\": { \"covered\": null, \"limit_raw\": null, \"source_ref\": null },\n    \"restoration_or_reload\": {\n      \"available\": null,\n      \"type\": null,\n      \"conditions\": null,\n      \"usage_rules\": null,\n      \"source_ref\": null\n    },\n    \"no_claim_bonus\": {\n      \"available\": null,\n      \"accrual_raw\": null,\n      \"max_raw\": null,\n      \"reduction_rules\": null,\n      \"source_ref\": null\n    }\n  },\n  \"exclusions\": {\n    \"standard_exclusions\": [\"exclusion item\"],\n    \"product_specific_exclusions\": [\n      { \"exclusion\": null, \"source_ref\": null }\n    ],\n    \"permanent_exclusions_or_ped_exclusions\": [\n      { \"item\": null, \"source_ref\": null }\n    ],\n    \"non_medical_items_consumables\": { \"covered_or_excluded\": null, \"notes\": null, \"source_ref\": null }\n  },\n  \"claims_and_admin\": {\n    \"cashless_process\": null,\n    \"reimbursement_process\": null,\n    \"claim_intimation_timeline\": null,\n    \"document_submission_timeline\": null,\n    \"claim_settlement_timeline\": null,\n    \"free_look_period\": null,\n    \"renewal_and_grace_period\": null,\n    \"portability\": null,\n    \"migration\": null,\n    \"cancellation_refund\": null,\n    \"customer_support\": {\n      \"insurer_helpline\": null,\n      \"tpa_helpline\": null,\n      \"email\": null,\n      \"website\": null,\n      \"address\": null\n    }\n  },\n  \"plan_variants\": [\n    {\n      \"variant_name\": null,\n      \"variant_identifier\": null,\n      \"sum_insured_options\": null,\n      \"cost_sharing_overrides\": null,\n      \"limits_overrides\": null,\n      \"benefit_overrides\": null,\n      \"waiting_period_overrides\": null,\n      \"notes\": null\n    }\n  ],\n  \"notes\": {\n    \"missing_or_unclear\": [\"missing field note\"],\n    \"conflicts\": [\"conflict note\"],\n    \"assumptions\": [\"assumption note\"],\n    \"extraction_warnings\": [\"warning note\"]\n  },\n  \"source_map\": [\n    {\n      \"field_path\": null,\n      \"evidence_snippet\": null,\n      \"source_ref\": null\n    }\n  ]\n}"
      },
      "id": "deep_parser",
      "name": "Deep Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        1800,
        20
      ]
    },
    {
      "parameters": {
        "jsCode": "function extractJson(raw) {\n  if (raw && typeof raw === 'object') return raw;\n  const s = String(raw || '').trim();\n  try { return JSON.parse(s); } catch {}\n  const start = s.indexOf('{');\n  const end = s.lastIndexOf('}');\n  if (start !== -1 && end !== -1 && end > start) {\n    const sub = s.slice(start, end + 1);\n    try { return JSON.parse(sub); } catch {}\n  }\n  return {};\n}\n\nconst TEMPLATE = {\n  document_classification: { is_health_insurance: null, india_market: true, document_type: null, confidence: { overall: null, rationale: null } },\n  policy_metadata: { insurer_name: null, product_name: null, uin: null, plan_name: null, policy_type: null, individual_or_floater: null, policy_number: null, certificate_number: null, tpa_name: null, network: { cashless_available: null, network_name_or_partner: null, non_network_reimbursement_allowed: null }, policy_period: { start_date: null, end_date: null }, geography: { zone_or_city_tier: null, india_state: null, city: null }, sum_insured: { raw: null, amount: null, currency: 'INR', type: null }, insured_members: { count: null, relationships: null, entry_age_rules: null } },\n  premium_and_tax: { premium: { raw: null, amount: null, currency: 'INR', frequency: null }, gst_or_taxes: { raw: null, rate: null }, loadings_or_discounts: [] },\n  cost_sharing: { deductible: { raw: null, amount: null, currency: 'INR', per: null, notes: null }, co_pay: [], coinsurance: [] },\n  waiting_periods: { initial_waiting_period: { raw: null, accident_exception: null, source_ref: null }, ped_waiting_period: { raw: null, definition_of_ped: null, source_ref: null }, maternity_waiting_period: { raw: null, source_ref: null }, specific_disease_waiting_periods: [] },\n  limits_and_sublimits: { room_rent: { raw: null, type: null, notes: null, source_ref: null }, icu_rent: { raw: null, type: null, notes: null, source_ref: null }, procedure_or_disease_sublimits: [], ambulance_limit: { limit_raw: null, source_ref: null }, ayush_limit: { limit_raw: null, source_ref: null }, cataract_limit: { limit_raw: null, source_ref: null }, opd_limit: { limit_raw: null, source_ref: null }, annual_or_lifetime_limits: [] },\n  benefits: { hospitalization_inpatient: { covered: null, notes: null, source_ref: null }, pre_hospitalization: { covered: null, duration_raw: null, source_ref: null }, post_hospitalization: { covered: null, duration_raw: null, source_ref: null }, daycare: { covered: null, definition_or_list: null, source_ref: null }, domiciliary_hospitalization: { covered: null, conditions: null, source_ref: null }, modern_treatments: { covered: null, limits_or_list: null, source_ref: null }, organ_donor: { covered: null, limit_raw: null, source_ref: null }, maternity: { covered: null, limit_raw: null, newborn_covered: null, newborn_waiting_or_conditions: null, source_ref: null }, mental_health: { covered: null, notes: null, source_ref: null }, ayush: { covered: null, notes: null, source_ref: null }, health_checkups: { covered: null, frequency_raw: null, limit_raw: null, source_ref: null }, vaccination: { covered: null, limit_raw: null, source_ref: null }, teleconsultation: { covered: null, limit_raw: null, source_ref: null }, restoration_or_reload: { available: null, type: null, conditions: null, usage_rules: null, source_ref: null }, no_claim_bonus: { available: null, accrual_raw: null, max_raw: null, reduction_rules: null, source_ref: null } },\n  exclusions: { standard_exclusions: [], product_specific_exclusions: [], permanent_exclusions_or_ped_exclusions: [], non_medical_items_consumables: { covered_or_excluded: null, notes: null, source_ref: null } },\n  claims_and_admin: { cashless_process: null, reimbursement_process: null, claim_intimation_timeline: null, document_submission_timeline: null, claim_settlement_timeline: null, free_look_period: null, renewal_and_grace_period: null, portability: null, migration: null, cancellation_refund: null, customer_support: { insurer_helpline: null, tpa_helpline: null, email: null, website: null, address: null } },\n  plan_variants: [],\n  notes: { missing_or_unclear: [], conflicts: [], assumptions: [], extraction_warnings: [] },\n  source_map: []\n};\n\nfunction mergeWithTemplate(template, data) {\n  if (Array.isArray(template)) {\n    return Array.isArray(data) ? data : [];\n  }\n  if (template && typeof template === 'object') {\n    const out = {};\n    const src = (data && typeof data === 'object') ? data : {};\n    for (const k of Object.keys(template)) out[k] = mergeWithTemplate(template[k], src[k]);\n    return out;\n  }\n  if (data === undefined) return template;\n  return data;\n}\n\nreturn $input.all().map((item) => {\n  const raw = item.json.policy_json ?? item.json.output ?? item.json.text ?? item.json.response ?? item.json.result ?? item.json;\n  const parsed = extractJson(raw);\n  const policy = mergeWithTemplate(TEMPLATE, parsed);\n  if (!policy.notes) policy.notes = { missing_or_unclear: [], conflicts: [], assumptions: [], extraction_warnings: [] };\n  if (!Array.isArray(policy.notes.missing_or_unclear)) policy.notes.missing_or_unclear = [];\n  if (!Array.isArray(policy.notes.conflicts)) policy.notes.conflicts = [];\n  if (!Array.isArray(policy.notes.assumptions)) policy.notes.assumptions = [];\n  if (!Array.isArray(policy.notes.extraction_warnings)) policy.notes.extraction_warnings = [];\n  return { json: { ...item.json, policy_json: policy } };\n});"
      },
      "id": "validator_repair",
      "name": "Validator/Repair",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2020,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item => ({ json: { status: 'ok', policy: item.json.policy_json || item.json, text_hash: item.json.text_hash } }));"
      },
      "id": "assemble_ok",
      "name": "Assemble Final Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        220
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.entrypoint}}",
                    "rightValue": "webhook",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "webhook"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.entrypoint}}",
                    "rightValue": "chat",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "chat"
            }
          ]
        },
        "fallbackOutput": "webhook"
      },
      "id": "entry_router",
      "name": "Entrypoint Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        2460,
        20
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$json.response_payload || $json}}",
        "options": {}
      },
      "id": "respond_webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2680,
        -80
      ]
    },
    {
      "parameters": {
        "keepOnlySet": false,
        "values": {
          "string": [
            {
              "name": "chat_message",
              "value": "={{$json.status === 'needs_context' ? 'Need more context: ' + ($json.questions || []).map((q,i)=>`${i+1}) ${q.question}`).join(' | ') : `Parsed policy: ${$json.policy?.policy_metadata?.insurer_name || 'n/a'} / ${$json.policy?.policy_metadata?.product_name || 'n/a'}, SI: ${$json.policy?.policy_metadata?.sum_insured?.raw || 'n/a'}`}}"
            }
          ]
        }
      },
      "id": "respond_chat",
      "name": "Final Chat Output",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2680,
        120
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "policy-context",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "context_webhook",
      "name": "Context Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1320,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = this.getWorkflowStaticData('global');\nreturn $input.all().map(item => {\n  const text_hash = item.json.body?.text_hash || item.json.text_hash;\n  const user_context = item.json.body?.user_context || item.json.user_context || {};\n  const pending = text_hash ? data[text_hash] : null;\n  if (!pending) {\n    return { json: { status: 'needs_file_resend', text_hash, message: 'No pending context found. Please resend file with user_context.' } };\n  }\n  return {\n    json: {\n      entrypoint: 'webhook',\n      file_meta: pending.file_meta || {},\n      binary_property_name: pending.binary_property_name || 'file',\n      extracted_text: pending.extracted_text || '',\n      scanner: { detected: pending.scanner || {} },\n      gap: {},\n      user_context,\n      policy_json: {},\n      text_hash\n    }\n  };\n});"
      },
      "id": "resume_router",
      "name": "Resume Router",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1080,
        420
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{$json.status}}",
              "rightValue": "needs_file_resend",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "resume_pending_if",
      "name": "Resume Pending? (IF)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -860,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map((item)=>{\n  const out = { ...item.json };\n  out.scanner = {\n    detected: item.json.detected ?? item.json.scanner?.detected ?? null,\n    evidence: item.json.evidence ?? item.json.scanner?.evidence ?? [],\n    confidence: item.json.confidence ?? item.json.scanner?.confidence ?? null\n  };\n  return { json: out, binary: item.binary };\n});"
      },
      "id": "post_scanner_mapper",
      "name": "Map Scanner Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        -40
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map((item)=>{\n  const out = { ...item.json };\n  out.gap = {\n    need_user_input: item.json.need_user_input ?? item.json.gap?.need_user_input ?? null,\n    questions: item.json.questions ?? item.json.gap?.questions ?? [],\n    assumptions_if_unanswered: item.json.assumptions_if_unanswered ?? item.json.gap?.assumptions_if_unanswered ?? [],\n    stop_condition: item.json.stop_condition ?? item.json.gap?.stop_condition ?? null\n  };\n  return { json: out, binary: item.binary };\n});"
      },
      "id": "post_gap_mapper",
      "name": "Map Gap Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1280,
        -40
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map((item)=>{\n  const out = { ...item.json };\n  out.policy_json = item.json.policy_json ?? item.json.output ?? item.json;\n  return { json: out, binary: item.binary };\n});"
      },
      "id": "post_deep_mapper",
      "name": "Map Deep Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1940,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "function splitSections(text){\n  const headings=[/\\bbenefits?\\b/i,/\\bwaiting periods?\\b/i,/\\bexclusions?\\b/i,/\\bclaims?\\b/i,/\\bdefinitions?\\b/i,/\\bschedule\\b/i,/\\bsub-?limits?\\b/i,/\\broom rent\\b/i];\n  const lines=String(text||'').split(/\\r?\\n/);\n  const chunks=[];\n  let cur={title:'general',content:[]};\n  for(const line of lines){\n    const isHead=headings.some(r=>r.test(line.trim())) && line.trim().length<120;\n    if(isHead && cur.content.length){chunks.push({title:cur.title,text:cur.content.join('\\n')});cur={title:line.trim().toLowerCase(),content:[]};}\n    else cur.content.push(line);\n  }\n  if(cur.content.length)chunks.push({title:cur.title,text:cur.content.join('\\n')});\n  return chunks.filter(c=>c.text.trim());\n}\nreturn $input.all().map(item=>{\n  const t=item.json.extracted_text||'';\n  return {json:{...item.json,doc_text_full:t,doc_text_head:(item.json.first_25000_chars||t.slice(0,25000)),chunks:splitSections(t)},binary:item.binary};\n});"
      },
      "id": "chunk_by_sections",
      "name": "Chunk by Section",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        -40
      ]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0
        }
      },
      "id": "openai_chat_model_classifier",
      "name": "OpenAI Chat Model (Classifier)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        640,
        -300
      ],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Document Type Classifier (India Health).\\n\\nFILE_META:\\n{{$json.file_meta}}\\n\\nDOCUMENT HEAD:\\n{{$json.doc_text_head}}\\n\\nClassify quickly and return strict JSON only.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Detect doc type and schedule signals only. Unknown=>null/unknown. No hallucinations."
        }
      },
      "id": "document_type_classifier",
      "name": "Document Type Classifier",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        860,
        -40
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"document_type\": \"unknown\",\n  \"is_health_insurance\": null,\n  \"has_benefit_table\": null,\n  \"has_schedule_fields\": null,\n  \"confidence\": { \"overall\": null, \"notes\": null },\n  \"evidence\": [\n    { \"field\": null, \"snippet\": null, \"source_ref\": null }\n  ]\n}"
      },
      "id": "classifier_parser",
      "name": "Classifier Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        860,
        -260
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item=>({json:{...item.json,classifier:{document_type:item.json.document_type??'unknown',is_health_insurance:item.json.is_health_insurance??null,has_benefit_table:item.json.has_benefit_table??null,has_schedule_fields:item.json.has_schedule_fields??null,confidence:item.json.confidence??null,evidence:item.json.evidence??[]}},binary:item.binary}));"
      },
      "id": "map_classifier_output",
      "name": "Map Classifier Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        -40
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Table & Limits Extractor (India).\\n\\nFILE_META:\\n{{$json.file_meta}}\\n\\nCLASSIFIER:\\n{{$json.classifier}}\\n\\nRELEVANT CHUNKS (tables/limits/schedule):\\n{{$json.chunks}}\\n\\nExtract only table/limits fields as strict JSON.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Focus on SI, room rent, ICU, sublimits, copay, deductible, waiting numbers. Unknown null."
        }
      },
      "id": "table_limits_extractor",
      "name": "Table & Limits Extractor",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1580,
        80
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"policy_metadata\": {\n    \"sum_insured\": {\"raw\": null, \"amount\": null, \"currency\": \"INR\", \"type\": null}\n  },\n  \"cost_sharing\": {\n    \"deductible\": {\"raw\": null, \"amount\": null, \"currency\": \"INR\", \"per\": null, \"notes\": null},\n    \"co_pay\": [],\n    \"coinsurance\": []\n  },\n  \"waiting_periods\": {\n    \"initial_waiting_period\": {\"raw\": null, \"accident_exception\": null, \"source_ref\": null},\n    \"ped_waiting_period\": {\"raw\": null, \"definition_of_ped\": null, \"source_ref\": null}\n  },\n  \"limits_and_sublimits\": {\n    \"room_rent\": {\"raw\": null, \"type\": null, \"notes\": null, \"source_ref\": null},\n    \"icu_rent\": {\"raw\": null, \"type\": null, \"notes\": null, \"source_ref\": null},\n    \"procedure_or_disease_sublimits\": []\n  },\n  \"benefits\": {\n    \"restoration_or_reload\": {\"available\": null, \"type\": null, \"conditions\": null, \"usage_rules\": null, \"source_ref\": null},\n    \"no_claim_bonus\": {\"available\": null, \"accrual_raw\": null, \"max_raw\": null, \"reduction_rules\": null, \"source_ref\": null}\n  },\n  \"source_map\": []\n}"
      },
      "id": "table_parser",
      "name": "Table Extractor Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        1580,
        -100
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item=>({json:{...item.json,table_json:item.json},binary:item.binary}));"
      },
      "id": "map_table_output",
      "name": "Map Table Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        80
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Narrative Extractor (India).\\n\\nFILE_META:\\n{{$json.file_meta}}\\n\\nCLASSIFIER:\\n{{$json.classifier}}\\n\\nRELEVANT CHUNKS (exclusions/claims/definitions/conditions):\\n{{$json.chunks}}\\n\\nExtract only narrative clauses as strict JSON.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Focus exclusions, claims/admin timelines, cashless/reimbursement rules, portability, cancellation, definitions."
        }
      },
      "id": "narrative_extractor",
      "name": "Narrative Extractor",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1580,
        360
      ]
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"exclusions\": {\n    \"standard_exclusions\": [\"example\"],\n    \"product_specific_exclusions\": [],\n    \"permanent_exclusions_or_ped_exclusions\": [],\n    \"non_medical_items_consumables\": {\"covered_or_excluded\": null, \"notes\": null, \"source_ref\": null}\n  },\n  \"claims_and_admin\": {\n    \"cashless_process\": null,\n    \"reimbursement_process\": null,\n    \"claim_intimation_timeline\": null,\n    \"document_submission_timeline\": null,\n    \"claim_settlement_timeline\": null,\n    \"free_look_period\": null,\n    \"renewal_and_grace_period\": null,\n    \"portability\": null,\n    \"migration\": null,\n    \"cancellation_refund\": null\n  },\n  \"notes\": {\"missing_or_unclear\": [\"x\"], \"conflicts\": [\"x\"], \"assumptions\": [\"x\"], \"extraction_warnings\": [\"x\"]},\n  \"source_map\": []\n}"
      },
      "id": "narrative_parser",
      "name": "Narrative Extractor Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        1580,
        180
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item=>({json:{...item.json,narrative_json:item.json},binary:item.binary}));"
      },
      "id": "map_narrative_output",
      "name": "Map Narrative Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        360
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "merge_extractor_outputs",
      "name": "Merge Extractor Outputs",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1940,
        220
      ]
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item=>{\n  const j=item.json||{};\n  const table=j.table_json||{};\n  const nar=j.narrative_json||{};\n  const classifier=j.classifier||{};\n  const merged={...table,...nar};\n  const conflicts=[];\n  if ((classifier.document_type==='schedule of benefits'||classifier.document_type==='certificate of insurance') && table?.policy_metadata?.sum_insured?.raw && nar?.policy_metadata?.sum_insured?.raw && table.policy_metadata.sum_insured.raw!==nar.policy_metadata.sum_insured.raw){\n    conflicts.push('Schedule/certificate SI differs from wording; schedule/certificate preferred');\n  }\n  merged.notes=merged.notes||{missing_or_unclear:[],conflicts:[],assumptions:[],extraction_warnings:[]};\n  merged.notes.conflicts=[...(merged.notes.conflicts||[]),...conflicts];\n  return {json:{...j,policy_json:merged},binary:item.binary};\n});"
      },
      "id": "merge_policy_json",
      "name": "Merge Policy JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2120,
        220
      ]
    }
  ],
  "connections": {
    "Webhook Upload": {
      "main": [
        [
          {
            "node": "Normalize Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Upload": {
      "main": [
        [
          {
            "node": "Normalize Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Binary": {
      "main": [
        [
          {
            "node": "File Type Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "File Type Router": {
      "main": [
        [
          {
            "node": "Extract Text (Built-in)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Text (External)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Text (External)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text (Built-in)": {
      "main": [
        [
          {
            "node": "Merge Extracted Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text (External)": {
      "main": [
        [
          {
            "node": "Merge Extracted Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Extracted Text": {
      "main": [
        [
          {
            "node": "OCR Needed? (IF)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Needed? (IF)": {
      "main": [
        [
          {
            "node": "OCR Fallback",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Sanitize & Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR Fallback": {
      "main": [
        [
          {
            "node": "Sanitize & Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitize & Hash": {
      "main": [
        [
          {
            "node": "Chunk by Section",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model (Scanner)": {
      "ai_languageModel": [
        [
          {
            "node": "Policy Scanner",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Scanner Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Policy Scanner",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Policy Scanner": {
      "main": [
        [
          {
            "node": "Map Scanner Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model (Gap)": {
      "ai_languageModel": [
        [
          {
            "node": "Context Gap Detector",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Gap Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Context Gap Detector",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Context Gap Detector": {
      "main": [
        [
          {
            "node": "Map Gap Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Context? (IF)": {
      "main": [
        [
          {
            "node": "Store Pending Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Table & Limits Extractor",
            "type": "main",
            "index": 0
          },
          {
            "node": "Narrative Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Pending Context": {
      "main": [
        [
          {
            "node": "Assemble Needs Context Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Assemble Needs Context Response": {
      "main": [
        [
          {
            "node": "Entrypoint Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model (Deep)": {
      "ai_languageModel": [
        [
          {
            "node": "Table & Limits Extractor",
            "type": "ai_languageModel",
            "index": 0
          }
        ],
        [
          {
            "node": "Narrative Extractor",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Deep Extractor": {
      "main": [
        [
          {
            "node": "Map Deep Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validator/Repair": {
      "main": [
        [
          {
            "node": "Assemble Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Assemble Final Response": {
      "main": [
        [
          {
            "node": "Entrypoint Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Entrypoint Router": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Final Chat Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Context Webhook": {
      "main": [
        [
          {
            "node": "Resume Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resume Router": {
      "main": [
        [
          {
            "node": "Resume Pending? (IF)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resume Pending? (IF)": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Deep Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deep Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Deep Extractor",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Map Scanner Output": {
      "main": [
        [
          {
            "node": "Context Gap Detector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Gap Output": {
      "main": [
        [
          {
            "node": "Needs Context? (IF)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Deep Output": {
      "main": [
        [
          {
            "node": "Validator/Repair",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model (Classifier)": {
      "ai_languageModel": [
        [
          {
            "node": "Document Type Classifier",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Classifier Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Document Type Classifier",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Document Type Classifier": {
      "main": [
        [
          {
            "node": "Map Classifier Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Classifier Output": {
      "main": [
        [
          {
            "node": "Policy Scanner",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Table Extractor Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Table & Limits Extractor",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Narrative Extractor Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Narrative Extractor",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Table & Limits Extractor": {
      "main": [
        [
          {
            "node": "Map Table Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Narrative Extractor": {
      "main": [
        [
          {
            "node": "Map Narrative Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Table Output": {
      "main": [
        [
          {
            "node": "Merge Extractor Outputs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Narrative Output": {
      "main": [
        [
          {
            "node": "Merge Extractor Outputs",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Extractor Outputs": {
      "main": [
        [
          {
            "node": "Merge Policy JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Policy JSON": {
      "main": [
        [
          {
            "node": "Validator/Repair",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunk by Section": {
      "main": [
        [
          {
            "node": "Document Type Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "india-health-policy-analyzer-expert-architecture-cloud-v2-4-6",
  "meta": {
    "templateCredsSetupCompleted": false
  },
  "id": "IndiaHealthPolicyAnalyzerExpertArchitectureCloudV246",
  "tags": []
}